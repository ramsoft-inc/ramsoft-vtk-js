var vtkSurfaceLICInterface_CE = "//VTK::System::Dec\r\n\r\n//=========================================================================\r\n//\r\n//  Program:   Visualization Toolkit\r\n//  Module:    vtkSurfaceLICMapper_CE.glsl\r\n//\r\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\r\n//  All rights reserved.\r\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\r\n//\r\n//     This software is distributed WITHOUT ANY WARRANTY; without even\r\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\r\n//     PURPOSE.  See the above copyright notice for more information.\r\n//\r\n//=========================================================================\r\n\r\n// color contrast enhance stage implemented via histogram stretching\r\n// on lightness channel. if the min and max are tweaked it can generate\r\n// out-of-range values these will be clamped in 0 to 1\r\n\r\n// the output of this shader\r\n//VTK::Output::Dec\r\n\r\nuniform sampler2D texGeomColors; // scalars + lighting\r\nuniform sampler2D texLIC;        // image lic, mask\r\nuniform sampler2D texHSLColors;  // hsla colors\r\n\r\nuniform float     uLMin;         // min lightness over all fragments\r\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\r\n\r\nin vec2 tcoordVC;\r\n\r\nvec3 HSLToRGB(vec3 HSL)\r\n{\r\n  vec3 RGB;\r\n  float v;\r\n  float h = HSL.x;\r\n  float sl = HSL.y;\r\n  float l = HSL.z;\r\n\r\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\r\n  if (v <= 0.0) {\r\n    RGB = vec3(0.0,0.0,0.0);\r\n  } else {\r\n    float m;\r\n    int sextant;\r\n    float fract, vsf, mid1, mid2;\r\n\r\n    m = l + l - v;\r\n    h *= 6.0;\r\n    sextant = int(h);\r\n    fract = h - float(sextant);\r\n\r\n    vsf = (v - m) * fract;\r\n    mid1 = m + vsf;\r\n    mid2 = v - vsf;\r\n    switch (sextant) {\r\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\r\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\r\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\r\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\r\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\r\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\r\n    }\r\n  }\r\n  return RGB;\r\n}\r\n\r\nvoid main()\r\n{\r\n  // lookup hsl color , mask\r\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\r\n\r\n  // don't modify masked fragments (masked => lic.g==1)\r\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\r\n  if (lic.g==0.0)\r\n    {\r\n    // normalize lightness channel\r\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\r\n    }\r\n\r\n  // back into rgb space\r\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\r\n\r\n  // add alpha\r\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\r\n  fragColor.a = geomColor.a;\r\n\r\n  gl_FragData[0] = fragColor;\r\n}\r\n";

export { vtkSurfaceLICInterface_CE as v };
