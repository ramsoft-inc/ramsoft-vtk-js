var vtkLineIntegralConvolution2D_SC = "//VTK::System::Dec\r\n\r\n//=========================================================================\r\n//\r\n//  Program:   Visualization Toolkit\r\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\r\n//\r\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\r\n//  All rights reserved.\r\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\r\n//\r\n//     This software is distributed WITHOUT ANY WARRANTY; without even\r\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\r\n//     PURPOSE.  See the above copyright notice for more information.\r\n//\r\n//=========================================================================\r\n\r\n// This shader combines surface geometry, LIC, and  scalar colors.\r\n\r\n// the output of this shader\r\nlayout(location = 0) out vec4 RGBOutput;\r\nlayout(location = 1) out vec4 HSLOutput;\r\n\r\nuniform sampler2D texVectors;       // vectors, depth\r\nuniform sampler2D texGeomColors;    // scalar colors + lighting\r\nuniform sampler2D texLIC;           // image lic\r\nuniform int       uScalarColorMode; // select between blend, and map shader\r\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\r\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\r\nuniform float     uMaskIntensity;   // blending factor for mask color\r\nuniform vec3      uMaskColor;       // color for the masked out fragments\r\n\r\nin vec2 tcoordVC;\r\n\r\n/**\r\nConvert from RGB color space into HSL colorspace.\r\n*/\r\nvec3 RGBToHSL(vec3 RGB)\r\n{\r\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\r\n\r\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\r\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\r\n  float RGBMaxMinDiff = RGBMax - RGBMin;\r\n\r\n  HSL.z = (RGBMax + RGBMin) / 2.0;\r\n\r\n  if (RGBMaxMinDiff == 0.0)\r\n    {\r\n    // Gray scale\r\n    HSL.x = 0.0;\r\n    HSL.y = 0.0;\r\n    }\r\n  else\r\n    {\r\n    // Color\r\n    if (HSL.z < 0.5)\r\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\r\n    else\r\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\r\n\r\n    float dR\r\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\r\n    float dG\r\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\r\n    float dB\r\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\r\n\r\n    if (RGB.r == RGBMax)\r\n      HSL.x = dB - dG;\r\n    else\r\n    if (RGB.g == RGBMax)\r\n      HSL.x = (1.0 / 3.0) + dR - dB;\r\n    else\r\n    if (RGB.b == RGBMax)\r\n      HSL.x = (2.0 / 3.0) + dG - dR;\r\n\r\n    if (HSL.x < 0.0)\r\n      HSL.x += 1.0;\r\n\r\n    if (HSL.x > 1.0)\r\n      HSL.x -= 1.0;\r\n    }\r\n\r\n  return HSL;\r\n}\r\n\r\n/**\r\nHelper for HSL to RGB conversion.\r\n*/\r\nfloat Util(float v1, float v2, float vH)\r\n{\r\n  if (vH < 0.0)\r\n    vH += 1.0;\r\n\r\n  if (vH > 1.0)\r\n     vH -= 1.0;\r\n\r\n  if ((6.0 * vH) < 1.0)\r\n    return (v1 + (v2 - v1) * 6.0 * vH);\r\n\r\n  if ((2.0 * vH) < 1.0)\r\n    return (v2);\r\n\r\n  if ((3.0 * vH) < 2.0)\r\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\r\n\r\n  return v1;\r\n}\r\n\r\n/**\r\nConvert from HSL space into RGB space.\r\n*/\r\nvec3 HSLToRGB(vec3 HSL)\r\n{\r\n  vec3 RGB;\r\n  if (HSL.y == 0.0)\r\n    {\r\n    // Gray\r\n    RGB.r = HSL.z;\r\n    RGB.g = HSL.z;\r\n    RGB.b = HSL.z;\r\n    }\r\n  else\r\n    {\r\n    // Chromatic\r\n    float v2;\r\n    if (HSL.z < 0.5)\r\n      v2 = HSL.z * (1.0 + HSL.y);\r\n    else\r\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\r\n\r\n    float v1 = 2.0 * HSL.z - v2;\r\n\r\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\r\n    RGB.g = Util(v1, v2, HSL.x);\r\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\r\n    }\r\n\r\n  return RGB.rgb;\r\n}\r\n\r\nvoid main()\r\n{\r\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\r\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\r\n\r\n  // depth is used to determine which fragment belong to us\r\n  // and we can change\r\n  float depth = texture2D(texVectors, tcoordVC.st).a;\r\n\r\n  vec3 fragColorRGB;\r\n  float valid;\r\n  if (depth > 1.0e-3)\r\n    {\r\n    // we own it\r\n    // shade LIC'ed geometry, or apply mask\r\n    if (lic.g!=0.0)\r\n      {\r\n      // it's masked\r\n      // apply fragment mask\r\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\r\n      valid = 0.0;\r\n      }\r\n    else\r\n      {\r\n      if (uScalarColorMode==0)\r\n        {\r\n        // blend with scalars\r\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\r\n        }\r\n      else\r\n        {\r\n        // multiply with scalars\r\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\r\n        }\r\n      if (lic.b != 0.0)\r\n        {\r\n        // didn't have the required guard pixels\r\n        // don't consider it in min max estimation\r\n        // for histpgram stretching\r\n        valid = 0.0;\r\n        }\r\n      else\r\n        {\r\n        // ok to use in min/max estimates for histogram\r\n        // stretching\r\n        valid = 1.0;\r\n        }\r\n      }\r\n    }\r\n  else\r\n    {\r\n    // we don't own it\r\n    // pass through scalars\r\n    fragColorRGB = geomColor.rgb;\r\n    valid = 0.0;\r\n    }\r\n\r\n  // if no further stages this texture is\r\n  // copied to the screen\r\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\r\n\r\n  // if further stages, move to hsl space for contrast\r\n  // enhancement. encoding validity saves moving a texture to the cpu\r\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\r\n  HSLOutput = vec4(fragColorHSL, valid);\r\n}\r\n";

export { vtkLineIntegralConvolution2D_SC as v };
