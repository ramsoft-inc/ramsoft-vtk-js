var vtkLineIntegralConvolution2D_AAH = "//VTK::System::Dec\r\n\r\n//=========================================================================\r\n//\r\n//  Program:   Visualization Toolkit\r\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\r\n//\r\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\r\n//  All rights reserved.\r\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\r\n//\r\n//     This software is distributed WITHOUT ANY WARRANTY; without even\r\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\r\n//     PURPOSE.  See the above copyright notice for more information.\r\n//\r\n//=========================================================================\r\n\r\n// Anti-alias stage in vtkLineIntegralConvolution2D\r\n// horizontal pass of a Gaussian convolution\r\n\r\n// the output of this shader\r\nlayout(location = 0) out vec4 LICOutput;\r\nlayout(location = 1) out vec4 SeedOutput;\r\n\r\nuniform sampler2D texLIC; // input texture\r\nuniform float     uDx;    // fragment size\r\n\r\nin vec2 tcoordVC;\r\n\r\n// factored 3x3 Gaussian kernel\r\n// K^T*K = G\r\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\r\n\r\n// determine if the fragment was masked\r\nbool Masked(float val){ return val != 0.0; }\r\n\r\nvoid main(void)\r\n{\r\n// neighbor offsets\r\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\r\n\r\n  vec2 lictc = tcoordVC.st;\r\n  vec4 lic[3];\r\n  bool dontUse = false;\r\n  float conv = 0.0;\r\n  for (int i=0; i<3; ++i)\r\n    {\r\n    vec2 tc = lictc + fragDx[i];\r\n    lic[i] = texture2D(texLIC, tc);\r\n    dontUse = dontUse || Masked(lic[i].g);\r\n    conv = conv + K[i] * lic[i].r;\r\n    }\r\n  // output is (conv, mask, skip, 1)\r\n  if (dontUse)\r\n    {\r\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\r\n    }\r\n  else\r\n    {\r\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\r\n    }\r\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\r\n}\r\n";

export { vtkLineIntegralConvolution2D_AAH as v };
