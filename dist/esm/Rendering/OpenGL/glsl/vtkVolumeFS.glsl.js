var vtkVolumeFS = "//VTK::System::Dec\r\n\r\n/*=========================================================================\r\n\r\n  Program:   Visualization Toolkit\r\n  Module:    vtkVolumeFS.glsl\r\n\r\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\r\n  All rights reserved.\r\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\r\n\r\n     This software is distributed WITHOUT ANY WARRANTY; without even\r\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\r\n     PURPOSE.  See the above copyright notice for more information.\r\n\r\n=========================================================================*/\r\n// Template for the volume mappers fragment shader\r\n\r\n// the output of this shader\r\n//VTK::Output::Dec\r\n\r\nvarying vec3 vertexVCVSOutput;\r\n\r\n// first declare the settings from the mapper\r\n// that impact the code paths in here\r\n\r\n// always set vtkNumComponents 1,2,3,4\r\n//VTK::NumComponents\r\n\r\n// possibly define vtkTrilinearOn\r\n//VTK::TrilinearOn\r\n\r\n// possibly define vtkIndependentComponents\r\n//VTK::IndependentComponentsOn\r\n\r\n// possibly define any \"proportional\" components\r\n//VTK::vtkProportionalComponents\r\n\r\n// Define the blend mode to use\r\n#define vtkBlendMode //VTK::BlendMode\r\n\r\n// Possibly define vtkImageLabelOutlineOn\r\n//VTK::ImageLabelOutlineOn\r\n\r\n#ifdef vtkImageLabelOutlineOn\r\n\r\nuniform float outlineOpacity;\r\nuniform float vpWidth;\r\nuniform float vpHeight;\r\nuniform float vpOffsetX;\r\nuniform float vpOffsetY;\r\nuniform mat4 PCWCMatrix;\r\nuniform mat4 vWCtoIDX;\r\n#endif\r\n\r\n// define vtkLightComplexity\r\n//VTK::LightComplexity\r\n#if vtkLightComplexity > 0\r\nuniform float vSpecularPower;\r\nuniform float vAmbient;\r\nuniform float vDiffuse;\r\nuniform float vSpecular;\r\n//VTK::Light::Dec\r\n#endif\r\n\r\n//VTK::VolumeShadowOn\r\n//VTK::SurfaceShadowOn\r\n//VTK::localAmbientOcclusionOn\r\n//VTK::LAO::Dec\r\n//VTK::VolumeShadow::Dec\r\n\r\n// define vtkComputeNormalFromOpacity\r\n//VTK::vtkComputeNormalFromOpacity\r\n\r\n// possibly define vtkGradientOpacityOn\r\n//VTK::GradientOpacityOn\r\n#ifdef vtkGradientOpacityOn\r\nuniform float goscale0;\r\nuniform float goshift0;\r\nuniform float gomin0;\r\nuniform float gomax0;\r\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\r\nuniform float goscale1;\r\nuniform float goshift1;\r\nuniform float gomin1;\r\nuniform float gomax1;\r\n#if vtkNumComponents >= 3\r\nuniform float goscale2;\r\nuniform float goshift2;\r\nuniform float gomin2;\r\nuniform float gomax2;\r\n#endif\r\n#if vtkNumComponents >= 4\r\nuniform float goscale3;\r\nuniform float goshift3;\r\nuniform float gomin3;\r\nuniform float gomax3;\r\n#endif\r\n#endif\r\n#endif\r\n\r\n// if you want to see the raw tiled\r\n// data in webgl1 uncomment the following line\r\n// #define debugtile\r\n\r\n// camera values\r\nuniform float camThick;\r\nuniform float camNear;\r\nuniform float camFar;\r\nuniform int cameraParallel;\r\n\r\n// values describing the volume geometry\r\nuniform vec3 vOriginVC;\r\nuniform vec3 vSpacing;\r\nuniform ivec3 volumeDimensions; // 3d texture dimensions\r\nuniform vec3 vPlaneNormal0;\r\nuniform float vPlaneDistance0;\r\nuniform vec3 vPlaneNormal1;\r\nuniform float vPlaneDistance1;\r\nuniform vec3 vPlaneNormal2;\r\nuniform float vPlaneDistance2;\r\nuniform vec3 vPlaneNormal3;\r\nuniform float vPlaneDistance3;\r\nuniform vec3 vPlaneNormal4;\r\nuniform float vPlaneDistance4;\r\nuniform vec3 vPlaneNormal5;\r\nuniform float vPlaneDistance5;\r\n\r\n//VTK::ClipPlane::Dec\r\n\r\n// opacity and color textures\r\nuniform sampler2D otexture;\r\nuniform float oshift0;\r\nuniform float oscale0;\r\nuniform sampler2D ctexture;\r\nuniform float cshift0;\r\nuniform float cscale0;\r\n\r\n// jitter texture\r\nuniform sampler2D jtexture;\r\nuniform sampler2D ttexture;\r\n\r\n\r\n// some 3D texture values\r\nuniform float sampleDistance;\r\nuniform vec3 vVCToIJK;\r\n\r\n// the heights defined below are the locations\r\n// for the up to four components of the tfuns\r\n// the tfuns have a height of 2XnumComps pixels so the\r\n// values are computed to hit the middle of the two rows\r\n// for that component\r\n#ifdef vtkIndependentComponentsOn\r\n#if vtkNumComponents == 2\r\nuniform float mix0;\r\nuniform float mix1;\r\n#define height0 0.25\r\n#define height1 0.75\r\n#endif\r\n#if vtkNumComponents == 3\r\nuniform float mix0;\r\nuniform float mix1;\r\nuniform float mix2;\r\n#define height0 0.17\r\n#define height1 0.5\r\n#define height2 0.83\r\n#endif\r\n#if vtkNumComponents == 4\r\nuniform float mix0;\r\nuniform float mix1;\r\nuniform float mix2;\r\nuniform float mix3;\r\n#define height0 0.125\r\n#define height1 0.375\r\n#define height2 0.625\r\n#define height3 0.875\r\n#endif\r\n#endif\r\n\r\n#if vtkNumComponents >= 2\r\nuniform float oshift1;\r\nuniform float oscale1;\r\nuniform float cshift1;\r\nuniform float cscale1;\r\n#endif\r\n#if vtkNumComponents >= 3\r\nuniform float oshift2;\r\nuniform float oscale2;\r\nuniform float cshift2;\r\nuniform float cscale2;\r\n#endif\r\n#if vtkNumComponents >= 4\r\nuniform float oshift3;\r\nuniform float oscale3;\r\nuniform float cshift3;\r\nuniform float cscale3;\r\n#endif\r\n\r\nuniform vec4 ipScalarRangeMin;\r\nuniform vec4 ipScalarRangeMax;\r\n\r\n// declaration for intermixed geometry\r\n//VTK::ZBuffer::Dec\r\n\r\n//=======================================================================\r\n// global and custom variables (a temporary section before photorealistics rendering module is complete)\r\nvec3 rayDirVC;\r\nfloat sampleDistanceISVS;\r\nfloat sampleDistanceIS;\r\n\r\n#define SQRT3    1.7321\r\n#define INV4PI   0.0796\r\n#define EPSILON  0.001\r\n#define PI       3.1415\r\n#define PI2      9.8696\r\n\r\n//=======================================================================\r\n// Webgl2 specific version of functions\r\n#if __VERSION__ == 300\r\n\r\nuniform highp sampler3D texture1;\r\n\r\nvec4 getTextureValue(vec3 pos)\r\n{\r\n  vec4 tmp = texture(texture1, pos);\r\n#if vtkNumComponents == 1\r\n  tmp.a = tmp.r;\r\n#endif\r\n#if vtkNumComponents == 2\r\n  tmp.a = tmp.g;\r\n#endif\r\n#if vtkNumComponents == 3\r\n  tmp.a = length(tmp.rgb);\r\n#endif\r\n  return tmp;\r\n}\r\n\r\n//=======================================================================\r\n// WebGL1 specific version of functions\r\n#else\r\n\r\nuniform sampler2D texture1;\r\n\r\nuniform float texWidth;\r\nuniform float texHeight;\r\nuniform int xreps;\r\nuniform int xstride;\r\nuniform int ystride;\r\n\r\n// if computing trilinear values from multiple z slices\r\n#ifdef vtkTrilinearOn\r\nvec4 getTextureValue(vec3 ijk)\r\n{\r\n  float zoff = 1.0/float(volumeDimensions.z);\r\n  vec4 val1 = getOneTextureValue(ijk);\r\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\r\n\r\n  float indexZ = float(volumeDimensions)*ijk.z;\r\n  float zmix =  indexZ - floor(indexZ);\r\n\r\n  return mix(val1, val2, zmix);\r\n}\r\n\r\nvec4 getOneTextureValue(vec3 ijk)\r\n#else // nearest or fast linear\r\nvec4 getTextureValue(vec3 ijk)\r\n#endif\r\n{\r\n  vec3 tdims = vec3(volumeDimensions);\r\n\r\n#ifdef debugtile\r\n  vec2 tpos = vec2(ijk.x, ijk.y);\r\n  vec4 tmp = texture2D(texture1, tpos);\r\n  tmp.a = 1.0;\r\n\r\n#else\r\n  int z = int(ijk.z * tdims.z);\r\n  int yz = z / xreps;\r\n  int xz = z - yz*xreps;\r\n\r\n  int tileWidth = volumeDimensions.x/xstride;\r\n  int tileHeight = volumeDimensions.y/ystride;\r\n\r\n  xz *= tileWidth;\r\n  yz *= tileHeight;\r\n\r\n  float ni = float(xz) + (ijk.x*float(tileWidth));\r\n  float nj = float(yz) + (ijk.y*float(tileHeight));\r\n\r\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\r\n\r\n  vec4 tmp = texture2D(texture1, tpos);\r\n\r\n#if vtkNumComponents == 1\r\n  tmp.a = tmp.r;\r\n#endif\r\n#if vtkNumComponents == 2\r\n  tmp.g = tmp.a;\r\n#endif\r\n#if vtkNumComponents == 3\r\n  tmp.a = length(tmp.rgb);\r\n#endif\r\n#endif\r\n\r\n  return tmp;\r\n}\r\n\r\n// End of Webgl1 specific code\r\n//=======================================================================\r\n#endif\r\n\r\n//=======================================================================\r\n// transformation between VC and IS space\r\n\r\n// convert vector position from idx to vc\r\n#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)\r\nvec3 IStoVC(vec3 posIS){\r\n  vec3 posVC = posIS / vVCToIJK;\r\n  return posVC.x * vPlaneNormal0 +\r\n         posVC.y * vPlaneNormal2 +\r\n         posVC.z * vPlaneNormal4 +\r\n         vOriginVC;\r\n}\r\n\r\n// convert vector position from vc to idx\r\nvec3 VCtoIS(vec3 posVC){\r\n  posVC = posVC - vOriginVC;\r\n  posVC = vec3(\r\n    dot(posVC, vPlaneNormal0),\r\n    dot(posVC, vPlaneNormal2),\r\n    dot(posVC, vPlaneNormal4));\r\n  return posVC * vVCToIJK;\r\n}\r\n#endif\r\n\r\n//Rotate vector to view coordinate\r\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\r\nvoid rotateToViewCoord(inout vec3 dirIS){\r\n  dirIS.xyz =\r\n    dirIS.x * vPlaneNormal0 +\r\n    dirIS.y * vPlaneNormal2 +\r\n    dirIS.z * vPlaneNormal4;\r\n}\r\n\r\n//Rotate vector to idx coordinate\r\nvec3 rotateToIDX(vec3 dirVC){\r\n  vec3 dirIS;\r\n  dirIS.xyz = vec3(\r\n    dot(dirVC, vPlaneNormal0),\r\n    dot(dirVC, vPlaneNormal2),\r\n    dot(dirVC, vPlaneNormal4));\r\n  return dirIS;\r\n}\r\n#endif\r\n\r\n//=======================================================================\r\n// Given a normal compute the gradient opacity factors\r\nfloat computeGradientOpacityFactor(\r\n  float normalMag, float goscale, float goshift, float gomin, float gomax)\r\n{\r\n#if defined(vtkGradientOpacityOn)\r\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\r\n#else\r\n  return 1.0;\r\n#endif\r\n}\r\n\r\n//=======================================================================\r\n// compute the normal and gradient magnitude for a position, uses forward difference\r\n#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)\r\n#ifdef vtkClippingPlanesOn\r\n  void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)\r\n  {\r\n    vec3 g1VC[3];\r\n    for (int i = 0; i < 3; ++i)\r\n    {\r\n      g1VC[i] = IStoVC(texPos[i]);\r\n    }\r\n    vec3 posVC = IStoVC(pos);\r\n    for (int i = 0; i < clip_numPlanes; ++i)\r\n    {\r\n      for (int j = 0; j < 3; ++j)\r\n      {\r\n        if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)\r\n        {\r\n          g1[j] = 0.0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n#endif\r\n\r\n  #ifdef vtkComputeNormalFromOpacity\r\n    #ifdef vtkGradientOpacityOn\r\n      vec4 computeDensityNormal(float gradientMag, vec3 scalarInterp[2])\r\n      {\r\n    #else\r\n      //if gradient opacity not on but using density gradient\r\n      vec4 computeDensityNormal(vec3 scalarInterp[2])\r\n      {\r\n    #endif\r\n        vec3 opacityG1, opacityG2;\r\n        opacityG1.x = texture2D(otexture, vec2(scalarInterp[0].x * oscale0 + oshift0, 0.5)).r;\r\n        opacityG1.y = texture2D(otexture, vec2(scalarInterp[0].y * oscale0 + oshift0, 0.5)).r;\r\n        opacityG1.z = texture2D(otexture, vec2(scalarInterp[0].z * oscale0 + oshift0, 0.5)).r;\r\n        opacityG2.x = texture2D(otexture, vec2(scalarInterp[1].x * oscale0 + oshift0, 0.5)).r;\r\n        opacityG2.y = texture2D(otexture, vec2(scalarInterp[1].y * oscale0 + oshift0, 0.5)).r;\r\n        opacityG2.z = texture2D(otexture, vec2(scalarInterp[1].z * oscale0 + oshift0, 0.5)).r;\r\n    #ifdef vtkGradientOpacityOn\r\n        float gradOpacityFactor = 1.0f;\r\n        if (gradientMag >= 0.0){\r\n          gradOpacityFactor = computeGradientOpacityFactor(gradientMag, goscale0, goshift0, gomin0, gomax0);\r\n        }\r\n        opacityG1.xyz *= gradOpacityFactor;\r\n        opacityG2.xyz *= gradOpacityFactor;\r\n    #endif\r\n\r\n        vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);\r\n        // divide by spacing\r\n        opacityG.xyz /= vSpacing;\r\n        opacityG.w = length(opacityG.xyz);\r\n        // rotate to View Coords\r\n        rotateToViewCoord(opacityG.xyz);\r\n        if (length(opacityG.xyz) > 0.0) {\r\n          return vec4(normalize(opacityG.xyz),opacityG.w);\r\n        } else {\r\n          return vec4(0.0);\r\n        }\r\n      }\r\n\r\n      vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2])\r\n      {\r\n        vec3 xvec = vec3(tstep.x, 0.0, 0.0);\r\n        vec3 yvec = vec3(0.0, tstep.y, 0.0);\r\n        vec3 zvec = vec3(0.0, 0.0, tstep.z);\r\n        vec3 texPosPVec[3];\r\n        texPosPVec[0] = pos + xvec;\r\n        texPosPVec[1] = pos + yvec;\r\n        texPosPVec[2] = pos + zvec;\r\n        vec3 texPosNVec[3];\r\n        texPosNVec[0] = pos - xvec;\r\n        texPosNVec[1] = pos - yvec;\r\n        texPosNVec[2] = pos - zvec;\r\n        vec3 g1, g2;\r\n\r\n        scalarInterp[0].x = getTextureValue(texPosPVec[0]).a;\r\n        scalarInterp[0].y = getTextureValue(texPosPVec[1]).a;\r\n        scalarInterp[0].z = getTextureValue(texPosPVec[2]).a;\r\n        scalarInterp[1].x = getTextureValue(texPosNVec[0]).a;\r\n        scalarInterp[1].y = getTextureValue(texPosNVec[1]).a;\r\n        scalarInterp[1].z = getTextureValue(texPosNVec[2]).a;\r\n\r\n        #ifdef vtkClippingPlanesOn\r\n          adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);\r\n          adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);\r\n        #endif\r\n        vec4 result;\r\n        result.x = scalarInterp[0].x - scalarInterp[1].x;\r\n        result.y = scalarInterp[0].y - scalarInterp[1].y;\r\n        result.z = scalarInterp[0].z - scalarInterp[1].z;\r\n        // divide by spacing\r\n        result.xyz /= vSpacing;\r\n        result.w = length(result.xyz);\r\n        // rotate to View Coords\r\n        rotateToViewCoord(result.xyz);\r\n        if (length(result.xyz) > 0.0) {\r\n          return vec4(normalize(result.xyz),result.w);\r\n        } else {\r\n          return vec4(0.0);\r\n        }\r\n      }\r\n  #endif\r\n\r\n  vec4 computeNormal(vec3 pos, vec3 tstep)\r\n  {\r\n    vec3 xvec = vec3(tstep.x, 0.0, 0.0);\r\n    vec3 yvec = vec3(0.0, tstep.y, 0.0);\r\n    vec3 zvec = vec3(0.0, 0.0, tstep.z);\r\n    vec3 texPosPVec[3];\r\n    texPosPVec[0] = pos + xvec;\r\n    texPosPVec[1] = pos + yvec;\r\n    texPosPVec[2] = pos + zvec;\r\n    vec3 texPosNVec[3];\r\n    texPosNVec[0] = pos - xvec;\r\n    texPosNVec[1] = pos - yvec;\r\n    texPosNVec[2] = pos - zvec;\r\n    vec3 g1, g2;\r\n    g1.x = getTextureValue(texPosPVec[0]).a;\r\n    g1.y = getTextureValue(texPosPVec[1]).a;\r\n    g1.z = getTextureValue(texPosPVec[2]).a;\r\n    g2.x = getTextureValue(texPosNVec[0]).a;\r\n    g2.y = getTextureValue(texPosNVec[1]).a;\r\n    g2.z = getTextureValue(texPosNVec[2]).a;\r\n    #ifdef vtkClippingPlanesOn\r\n      adjustClippedVoxelValues(pos, texPosPVec, g1);\r\n      adjustClippedVoxelValues(pos, texPosNVec, g2);\r\n    #endif\r\n    vec4 result;\r\n    result = vec4(g1 - g2, -1.0);\r\n    // divide by spacing\r\n    result.xyz /= vSpacing;\r\n    result.w = length(result.xyz);\r\n    if (result.w > 0.0){\r\n      // rotate to View Coords\r\n      rotateToViewCoord(result.xyz);\r\n      return vec4(normalize(result.xyz),result.w);\r\n    } else {\r\n      return vec4(0.0);\r\n    }\r\n  }\r\n#endif\r\n\r\n#ifdef vtkImageLabelOutlineOn\r\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\r\n  vec4 pcPos = vec4(\r\n    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\r\n    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\r\n    (fragCoord.z - 0.5) * 2.0,\r\n    1.0);\r\n\r\n  vec4 worldCoord = PCWCMatrix * pcPos;\r\n  vec4 vertex = (worldCoord/worldCoord.w);\r\n\r\n  vec3 index = (vWCtoIDX * vertex).xyz;\r\n\r\n  // half voxel fix for labelmapOutline\r\n  return (index + vec3(0.5)) / vec3(volumeDimensions);\r\n}\r\n#endif\r\n\r\n//=======================================================================\r\n// compute the normals and gradient magnitudes for a position\r\n// for independent components\r\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\r\n{\r\n  mat4 result;\r\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\r\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\r\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\r\n\r\n  // divide by spacing\r\n  distX /= vSpacing.x;\r\n  distY /= vSpacing.y;\r\n  distZ /= vSpacing.z;\r\n\r\n  mat3 rot;\r\n  rot[0] = vPlaneNormal0;\r\n  rot[1] = vPlaneNormal2;\r\n  rot[2] = vPlaneNormal4;\r\n\r\n#if !defined(vtkComponent0Proportional)\r\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\r\n  result[0].a = length(result[0].xyz);\r\n  result[0].xyz *= rot;\r\n  if (result[0].w > 0.0)\r\n  {\r\n    result[0].xyz /= result[0].w;\r\n  }\r\n#endif\r\n\r\n// optionally compute the 2nd component\r\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\r\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\r\n  result[1].a = length(result[1].xyz);\r\n  result[1].xyz *= rot;\r\n  if (result[1].w > 0.0)\r\n  {\r\n    result[1].xyz /= result[1].w;\r\n  }\r\n#endif\r\n\r\n// optionally compute the 3rd component\r\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\r\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\r\n  result[2].a = length(result[2].xyz);\r\n  result[2].xyz *= rot;\r\n  if (result[2].w > 0.0)\r\n  {\r\n    result[2].xyz /= result[2].w;\r\n  }\r\n#endif\r\n\r\n// optionally compute the 4th component\r\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\r\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\r\n  result[3].a = length(result[3].xyz);\r\n  result[3].xyz *= rot;\r\n  if (result[3].w > 0.0)\r\n  {\r\n    result[3].xyz /= result[3].w;\r\n  }\r\n#endif\r\n\r\n  return result;\r\n}\r\n\r\n//=======================================================================\r\n// global shadow - secondary ray\r\n#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)\r\nfloat random()\r\n{\r\n  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);\r\n  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;\r\n  uint pcg_state = floatBitsToUint(jitter);\r\n  uint state = pcg_state;\r\n  pcg_state = pcg_state * uint(747796405) + uint(2891336453);\r\n  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\r\n  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;\r\n}\r\n#endif\r\n\r\n#ifdef VolumeShadowOn\r\n// henyey greenstein phase function\r\nfloat phase_function(float cos_angle)\r\n{\r\n  // divide by 2.0 instead of 4pi to increase intensity\r\n  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;\r\n}\r\n\r\n// Computes the intersection between a ray and a box\r\nstruct Hit\r\n{\r\n  float tmin;\r\n  float tmax;\r\n};\r\n\r\nstruct Ray\r\n{\r\n  vec3 origin;\r\n  vec3 dir;\r\n  vec3 invDir;\r\n};\r\n\r\nbool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)\r\n{\r\n  vec3 tbot = r.invDir * (boundMin - r.origin);\r\n  vec3 ttop = r.invDir * (boundMax - r.origin);\r\n  vec3 tmin = min(ttop, tbot);\r\n  vec3 tmax = max(ttop, tbot);\r\n  vec2 t = max(tmin.xx, tmin.yz);\r\n  float t0 = max(t.x, t.y);\r\n  t = min(tmax.xx, tmax.yz);\r\n  float t1 = min(t.x, t.y);\r\n  hit.tmin = t0;\r\n  hit.tmax = t1;\r\n  return t1 > max(t0,0.0);\r\n}\r\n\r\n// As BBoxIntersect requires the inverse of the ray coords,\r\n// this function is used to avoid numerical issues\r\nvoid safe_0_vector(inout Ray ray)\r\n{\r\n  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;\r\n  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;\r\n  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;\r\n}\r\n\r\nfloat volume_shadow(vec3 posIS, vec3 lightDirNormIS)\r\n{\r\n  float shadow = 1.0;\r\n  float opacity = 0.0;\r\n\r\n  // modify sample distance with a random number between 1.5 and 3.0\r\n  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());\r\n  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;\r\n\r\n  // in case the first sample near surface has a very tiled light ray, we need to offset start position\r\n  posIS += sampleDistanceISVS_jitter * lightDirNormIS;\r\n\r\n  // compute the start and end points for the ray\r\n  Ray ray;\r\n  Hit hit;\r\n  ray.origin = posIS;\r\n  ray.dir = lightDirNormIS;\r\n  safe_0_vector(ray);\r\n  ray.invDir = 1.0/ray.dir;\r\n\r\n  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))\r\n  {\r\n    return 1.0;\r\n  }\r\n  float maxdist = hit.tmax;\r\n\r\n  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach\r\n  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);\r\n  maxdist = min(maxdist,maxgi);\r\n  if(maxdist < EPSILON) {\r\n    return 1.0;\r\n  }\r\n\r\n  // support gradient opacity\r\n  #ifdef vtkGradientOpacityOn\r\n    vec4 normal;\r\n  #endif\r\n\r\n  float current_dist = 0.0;\r\n  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);\r\n  float clamped_step = 0.0;\r\n\r\n  vec4 scalar = vec4(0.0);\r\n  while(current_dist < maxdist)\r\n  {\r\n#ifdef vtkClippingPlanesOn\r\n    vec3 posVC = IStoVC(posIS);\r\n    for (int i = 0; i < clip_numPlanes; ++i)\r\n    {\r\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)\r\n      {\r\n        current_dist = maxdist;\r\n      }\r\n    }\r\n#endif\r\n    scalar = getTextureValue(posIS);\r\n    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;\r\n    #ifdef vtkGradientOpacityOn\r\n      normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));\r\n      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\r\n    #endif\r\n    shadow *= 1.0 - opacity;\r\n\r\n    // optimization: early termination\r\n    if (shadow < EPSILON){\r\n      return 0.0;\r\n    }\r\n\r\n    clamped_step = min(maxdist - current_dist, current_step);\r\n    posIS += clamped_step * lightDirNormIS;\r\n    current_dist += current_step;\r\n  }\r\n\r\n  return shadow;\r\n}\r\n\r\nvec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)\r\n{\r\n  vec3 vertLight = vec3(0.0);\r\n  vec3 secondary_contrib = vec3(0.0);\r\n  // here we assume only positional light, no effect of cones\r\n  for (int i = 0; i < lightNum; i++)\r\n  {\r\n    #if(vtkLightComplexity==3)\r\n      if (lightPositional[i] == 1){\r\n        vertLight = lightPositionVC[i] - IStoVC(posIS);\r\n      }else{\r\n        vertLight = - lightDirectionVC[i];\r\n      }\r\n    #else\r\n      vertLight = - lightDirectionVC[i];\r\n    #endif\r\n    // here we assume achromatic light, only intensity\r\n    float dDotL = dot(viewDirectionVC, normalize(vertLight));\r\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\r\n    float phase_attenuation = 0.5;\r\n    if (abs(anisotropy) > EPSILON){\r\n      phase_attenuation = phase_function(dDotL);\r\n    }\r\n    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));\r\n    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;\r\n    secondary_contrib += tColor * vAmbient;\r\n  }\r\n  return secondary_contrib;\r\n}\r\n#endif\r\n\r\n//=======================================================================\r\n// local ambient occlusion\r\n#ifdef localAmbientOcclusionOn\r\nvec3 sample_direction_uniform(int i)\r\n{\r\n  float rand = random() * 0.5;\r\n  float theta = PI2 * (kernelSample[i][0] + rand);\r\n  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;\r\n  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));\r\n}\r\n\r\n// return a matrix that transform startDir into z axis; startDir should be normalized\r\nmat3 zBaseRotationalMatrix(vec3 startDir){\r\n  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));\r\n  float cosA = startDir.z;\r\n  float k = 1.0 / (1.0 + cosA);\r\n  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,\r\n              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,\r\n              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);\r\n  return matrix;\r\n}\r\n\r\nfloat computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){\r\n  // apply LAO only at selected locations, otherwise return full brightness\r\n  if (normal.w > 0.0 && op > 0.05){\r\n    float total_transmittance = 0.0;\r\n    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));\r\n    vec3 currPos, randomDirStep;\r\n    float weight, transmittance, opacity;\r\n    for (int i = 0; i < kernelSize; i++)\r\n    {\r\n      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;\r\n      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));\r\n      currPos = posIS;\r\n      transmittance = 1.0;\r\n      for (int j = 0; j < kernelRadius ; j++){\r\n        currPos += randomDirStep;\r\n        // check if it's at clipping plane, if so return full brightness\r\n        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){\r\n          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;\r\n          #ifdef vtkGradientOpacityOn\r\n             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);\r\n          #endif\r\n          transmittance *= 1.0 - opacity;\r\n        }\r\n        else{\r\n          break;\r\n        }\r\n      }\r\n      total_transmittance += transmittance / float(kernelRadius) * weight;\r\n\r\n      // early termination if fully translucent\r\n      if (total_transmittance > 1.0 - EPSILON){\r\n        return 1.0;\r\n      }\r\n    }\r\n    // average transmittance and reduce variance\r\n    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);\r\n  } else {\r\n    return 1.0;\r\n  }\r\n}\r\n#endif\r\n\r\n//=======================================================================\r\n// surface light contribution\r\n#if vtkLightComplexity > 0\r\n  void applyLighting(inout vec3 tColor, vec4 normal)\r\n  {\r\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\r\n    vec3 specular = vec3(0.0, 0.0, 0.0);\r\n    float df, sf = 0.0;\r\n    for (int i = 0; i < lightNum; i++){\r\n        df = abs(dot(normal.rgb, -lightDirectionVC[i]));\r\n        diffuse += df * lightColor[i];\r\n        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);\r\n        specular += sf * lightColor[i];\r\n    }\r\n    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\r\n  }\r\n  #ifdef SurfaceShadowOn\r\n  #if vtkLightComplexity < 3\r\n    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)\r\n    {\r\n      // everything in VC\r\n      vec3 diffuse = vec3(0.0);\r\n      vec3 specular = vec3(0.0);\r\n      #ifdef localAmbientOcclusionOn\r\n        vec3 ambient = vec3(0.0);\r\n      #endif\r\n      vec3 vertLightDirection;\r\n      for (int i = 0; i < lightNum; i++){\r\n        float ndotL,vdotR;\r\n        vertLightDirection = lightDirectionVC[i];\r\n        ndotL = dot(normal.xyz, vertLightDirection);\r\n        if (ndotL < 0.0 && twoSidedLighting)\r\n        {\r\n          ndotL = -ndotL;\r\n        }\r\n        if (ndotL > 0.0)\r\n        {\r\n          diffuse += ndotL * lightColor[i];\r\n          //specular\r\n          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\r\n          if (vdotR > 0.0)\r\n          {\r\n            specular += pow(vdotR, vSpecularPower) * lightColor[i];\r\n          }\r\n        }\r\n        #ifdef localAmbientOcclusionOn\r\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\r\n        #endif\r\n      }\r\n      #ifdef localAmbientOcclusionOn\r\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\r\n      #else\r\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\r\n      #endif\r\n    }\r\n  #else\r\n    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)\r\n    {\r\n      // everything in VC\r\n      vec3 diffuse = vec3(0.0);\r\n      vec3 specular = vec3(0.0);\r\n      #ifdef localAmbientOcclusionOn\r\n        vec3 ambient = vec3(0.0);\r\n      #endif\r\n      vec3 vertLightDirection;\r\n      for (int i = 0; i < lightNum; i++){\r\n        float distance,attenuation,ndotL,vdotR;\r\n        vec3 lightDir;\r\n        if (lightPositional[i] == 1){\r\n          lightDir = lightDirectionVC[i];\r\n          vertLightDirection = posVC - lightPositionVC[i];\r\n          distance = length(vertLightDirection);\r\n          vertLightDirection = normalize(vertLightDirection);\r\n          attenuation = 1.0 / (lightAttenuation[i].x\r\n                              + lightAttenuation[i].y * distance\r\n                              + lightAttenuation[i].z * distance * distance);\r\n          // per OpenGL standard cone angle is 90 or less for a spot light\r\n          if (lightConeAngle[i] <= 90.0){\r\n            float coneDot = dot(vertLightDirection, lightDir);\r\n            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone\r\n              attenuation = attenuation * pow(coneDot, lightExponent[i]);\r\n            }\r\n            else {\r\n              attenuation = 0.0;\r\n            }\r\n          }\r\n          ndotL = dot(normal.xyz, vertLightDirection);\r\n          if (ndotL < 0.0 && twoSidedLighting)\r\n          {\r\n            ndotL = -ndotL;\r\n          }\r\n          if (ndotL > 0.0)\r\n          {\r\n            diffuse += ndotL * attenuation * lightColor[i];\r\n            //specular\r\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\r\n            if (vdotR > 0.0)\r\n            {\r\n              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];\r\n            }\r\n          }\r\n          #ifdef localAmbientOcclusionOn\r\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\r\n          #endif\r\n        } else {\r\n          vertLightDirection = lightDirectionVC[i];\r\n          ndotL = dot(normal.xyz, vertLightDirection);\r\n          if (ndotL < 0.0 && twoSidedLighting)\r\n          {\r\n            ndotL = -ndotL;\r\n          }\r\n          if (ndotL > 0.0)\r\n          {\r\n            diffuse += ndotL * lightColor[i];\r\n            //specular\r\n            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));\r\n            if (vdotR > 0.0)\r\n            {\r\n              specular += pow(vdotR, vSpecularPower) * lightColor[i];\r\n            }\r\n          }\r\n          #ifdef localAmbientOcclusionOn\r\n            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);\r\n          #endif\r\n        }\r\n      }\r\n      #ifdef localAmbientOcclusionOn\r\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;\r\n      #else\r\n        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;\r\n      #endif\r\n    }\r\n  #endif\r\n  #endif\r\n#endif\r\n\r\n//=======================================================================\r\n// Given a texture value compute the color and opacity\r\n//\r\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\r\n{\r\n#ifdef vtkImageLabelOutlineOn\r\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\r\n  vec4 centerValue = getTextureValue(centerPosIS);\r\n  bool pixelOnBorder = false;\r\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\r\n\r\n  // Get alpha of segment from opacity function.\r\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\r\n\r\n  int segmentIndex = int(centerValue.r * 255.0);\r\n  \r\n  // Use texture sampling for outlineThickness\r\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\r\n  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;\r\n\r\n  int actualThickness = int(textureValue * 255.0);\r\n\r\n  if (actualThickness == 0) {\r\n    return vec4(0, 0, 1, 1);\r\n  }\r\n\r\n  // If it is the background (segment index 0), we should quickly bail out. \r\n  // Previously, this was determined by tColor.a, which was incorrect as it\r\n  // prevented the outline from appearing when the fill is 0.\r\n  if (segmentIndex == 0){\r\n    return vec4(0, 0, 0, 0);\r\n  }\r\n\r\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\r\n  // Saves a bunch of needless checks on the background.\r\n  // TODO define epsilon when building shader?\r\n  for (int i = -actualThickness; i <= actualThickness; i++) {\r\n    for (int j = -actualThickness; j <= actualThickness; j++) {\r\n      if (i == 0 || j == 0) {\r\n        continue;\r\n      }\r\n\r\n      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\r\n        gl_FragCoord.y + float(j),\r\n        gl_FragCoord.z, gl_FragCoord.w);\r\n\r\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\r\n      vec4 value = getTextureValue(neighborPosIS);\r\n\r\n      // If any of my neighbours are not the same value as I\r\n      // am, this means I am on the border of the segment.\r\n      // We can break the loops\r\n      if (any(notEqual(value, centerValue))) {\r\n        pixelOnBorder = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (pixelOnBorder == true) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // If I am on the border, I am displayed at full opacity\r\n  if (pixelOnBorder == true) {\r\n    tColor.a = outlineOpacity;\r\n  }\r\n\r\n#else\r\n  // compute the normal and gradient magnitude if needed\r\n  // We compute it as a vec4 if possible otherwise a mat4\r\n  //\r\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\r\n\r\n  // compute the normal vectors as needed\r\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\r\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\r\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\r\n      #if !defined(vtkComponent0Proportional)\r\n        vec4 normal0 = normalMat[0];\r\n      #endif\r\n      #if !defined(vtkComponent1Proportional)\r\n        vec4 normal1 = normalMat[1];\r\n      #endif\r\n      #if vtkNumComponents > 2\r\n        #if !defined(vtkComponent2Proportional)\r\n          vec4 normal2 = normalMat[2];\r\n        #endif\r\n        #if vtkNumComponents > 3\r\n          #if !defined(vtkComponent3Proportional)\r\n            vec4 normal3 = normalMat[3];\r\n          #endif\r\n        #endif\r\n      #endif\r\n    #else\r\n      vec4 normalLight;\r\n      #ifdef vtkComputeNormalFromOpacity\r\n        vec3 scalarInterp[2];\r\n        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp);\r\n        if (length(normal0)>0.0){\r\n          #ifdef vtkGradientOpacityOn\r\n            normalLight = computeDensityNormal(normal0.w, scalarInterp);\r\n          #else\r\n            normalLight = computeDensityNormal(scalarInterp);\r\n          #endif\r\n          if (length(normalLight) == 0.0){\r\n            normalLight = normal0;\r\n          }\r\n        }\r\n      #else\r\n        vec4 normal0 = computeNormal(posIS, tstep);\r\n        normalLight = normal0;\r\n      #endif\r\n    #endif\r\n  #endif\r\n\r\n  // compute gradient opacity factors as needed\r\n  #if defined(vtkGradientOpacityOn)\r\n    #if !defined(vtkComponent0Proportional)\r\n      goFactor.x =\r\n        computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);\r\n    #endif\r\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\r\n      #if !defined(vtkComponent1Proportional)\r\n        goFactor.y =\r\n          computeGradientOpacityFactor(normal1.a, goscale1, goshift1, gomin1, gomax1);\r\n      #endif\r\n      #if vtkNumComponents > 2\r\n        #if !defined(vtkComponent2Proportional)\r\n          goFactor.z =\r\n            computeGradientOpacityFactor(normal2.a, goscale2, goshift2, gomin2, gomax2);\r\n        #endif\r\n        #if vtkNumComponents > 3\r\n          #if !defined(vtkComponent3Proportional)\r\n            goFactor.w =\r\n              computeGradientOpacityFactor(normal3.a, goscale3, goshift3, gomin3, gomax3);\r\n          #endif\r\n        #endif\r\n      #endif\r\n    #endif\r\n  #endif\r\n\r\n  // single component is always independent\r\n  #if vtkNumComponents == 1\r\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\r\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\r\n    if (tColor.a < EPSILON){\r\n      return vec4(0.0);\r\n    }\r\n  #endif\r\n\r\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\r\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\r\n    #if !defined(vtkComponent0Proportional)\r\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\r\n    #else\r\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\r\n      tColor *= pwfValue;\r\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\r\n    #endif\r\n\r\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\r\n    #if !defined(vtkComponent1Proportional)\r\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\r\n    #else\r\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\r\n      tColor1 *= pwfValue;\r\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\r\n    #endif\r\n\r\n    #if vtkNumComponents >= 3\r\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\r\n      #if !defined(vtkComponent2Proportional)\r\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\r\n      #else\r\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\r\n        tColor2 *= pwfValue;\r\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\r\n      #endif\r\n\r\n      #if vtkNumComponents >= 4\r\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\r\n        #if !defined(vtkComponent3Proportional)\r\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\r\n        #else\r\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\r\n          tColor3 *= pwfValue;\r\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\r\n        #endif\r\n      #endif\r\n    #endif\r\n  #else // then not independent\r\n\r\n  #if vtkNumComponents == 2\r\n    float lum = tValue.r * cscale0 + cshift0;\r\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\r\n    vec4 tColor = vec4(lum, lum, lum, alpha);\r\n  #endif\r\n  #if vtkNumComponents == 3\r\n    vec4 tColor;\r\n    tColor.r = tValue.r * cscale0 + cshift0;\r\n    tColor.g = tValue.g * cscale1 + cshift1;\r\n    tColor.b = tValue.b * cscale2 + cshift2;\r\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\r\n  #endif\r\n  #if vtkNumComponents == 4\r\n    vec4 tColor;\r\n    tColor.r = tValue.r * cscale0 + cshift0;\r\n    tColor.g = tValue.g * cscale1 + cshift1;\r\n    tColor.b = tValue.b * cscale2 + cshift2;\r\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\r\n  #endif\r\n  #endif // dependent\r\n\r\n  // apply lighting if requested as appropriate\r\n  #if vtkLightComplexity > 0\r\n    #if !defined(vtkComponent0Proportional)\r\n      #if vtkNumComponents == 1\r\n        #ifdef SurfaceShadowOn\r\n            #if vtkLightComplexity < 3\r\n                vec3 tColorS = applyLightingDirectional(posIS, tColor, normalLight);\r\n            #else\r\n                vec3 tColorS = applyLightingPositional(posIS, tColor, normalLight, IStoVC(posIS));\r\n            #endif\r\n        #endif\r\n\r\n        #ifdef VolumeShadowOn\r\n          vec3 tColorVS = applyShadowRay(tColor.rgb, posIS, rayDirVC);\r\n          #ifdef SurfaceShadowOn\r\n            float vol_coef = volumetricScatteringBlending * (1.0 - tColor.a / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);\r\n            tColor.rgb = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;\r\n          #else\r\n            tColor.rgb = tColorVS;\r\n          #endif\r\n        #else\r\n            tColor.rgb = tColorS;\r\n        #endif\r\n\r\n      #else\r\n        applyLighting(tColor.rgb, normal0);\r\n      #endif\r\n    #endif\r\n\r\n    #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\r\n      #if !defined(vtkComponent1Proportional)\r\n        applyLighting(tColor1, normal1);\r\n      #endif\r\n    #if vtkNumComponents >= 3\r\n      #if !defined(vtkComponent2Proportional)\r\n        applyLighting(tColor2, normal2);\r\n      #endif\r\n    #if vtkNumComponents >= 4\r\n      #if !defined(vtkComponent3Proportional)\r\n        applyLighting(tColor3, normal3);\r\n      #endif\r\n    #endif\r\n    #endif\r\n    #endif\r\n  #endif\r\n\r\n// perform final independent blend as needed\r\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\r\n  tColor.rgb += tColor1;\r\n#if vtkNumComponents >= 3\r\n  tColor.rgb += tColor2;\r\n#if vtkNumComponents >= 4\r\n  tColor.rgb += tColor3;\r\n#endif\r\n#endif\r\n#endif\r\n\r\n#endif\r\nreturn tColor;\r\n}\r\n\r\nbool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {\r\n  bool withinRange = false;\r\n  #if vtkNumComponents == 1\r\n    if (val.r >= min.r && val.r <= max.r) {\r\n      withinRange = true;\r\n    }\r\n  #endif\r\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2\r\n     if (val.r >= min.r && val.r <= max.r &&\r\n        val.g >= min.g && val.g <= max.g) {\r\n      withinRange = true;\r\n    }\r\n  #endif\r\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3\r\n    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&\r\n        all(lessThanEqual(val, ipScalarRangeMax))) {\r\n      withinRange = true;\r\n    }\r\n  #endif\r\n  return withinRange;\r\n}\r\n\r\n//=======================================================================\r\n// Apply the specified blend mode operation along the ray's path.\r\n//\r\nvoid applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)\r\n{\r\n  vec3 tstep = 1.0/tdims;\r\n\r\n  // start slightly inside and apply some jitter\r\n  vec3 delta = endIS - posIS;\r\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\r\n  float raySteps = length(delta)/sampleDistanceIS;\r\n\r\n  // avoid 0.0 jitter\r\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\r\n  float stepsTraveled = jitter;\r\n\r\n  // local vars for the loop\r\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\r\n  vec4 tValue;\r\n  vec4 tColor;\r\n\r\n  // if we have less than one step then pick the middle point\r\n  // as our value\r\n  // if (raySteps <= 1.0)\r\n  // {\r\n  //   posIS = (posIS + endIS)*0.5;\r\n  // }\r\n\r\n  // Perform initial step at the volume boundary\r\n  // compute the scalar\r\n  tValue = getTextureValue(posIS);\r\n\r\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\r\n    // now map through opacity and color\r\n    tColor = getColorForValue(tValue, posIS, tstep);\r\n\r\n    // handle very thin volumes\r\n    if (raySteps <= 1.0)\r\n    {\r\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\r\n      gl_FragData[0] = tColor;\r\n      return;\r\n    }\r\n\r\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\r\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\r\n    posIS += (jitter*stepIS);\r\n\r\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\r\n    {\r\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\r\n\r\n      // compute the scalar\r\n      tValue = getTextureValue(posIS);\r\n\r\n      // now map through opacity and color\r\n      tColor = getColorForValue(tValue, posIS, tstep);\r\n\r\n      float mix = (1.0 - color.a);\r\n\r\n      // this line should not be needed but nvidia seems to not handle\r\n      // the break correctly on windows/chrome 58 angle\r\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\r\n\r\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\r\n      stepsTraveled++;\r\n      posIS += stepIS;\r\n      if (color.a > 0.99) { color.a = 1.0; break; }\r\n    }\r\n\r\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\r\n    {\r\n      posIS = endIS;\r\n\r\n      // compute the scalar\r\n      tValue = getTextureValue(posIS);\r\n\r\n      // now map through opacity and color\r\n      tColor = getColorForValue(tValue, posIS, tstep);\r\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\r\n\r\n      float mix = (1.0 - color.a);\r\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\r\n    }\r\n\r\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\r\n  #endif\r\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\r\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\r\n    // Find maximum/minimum intensity along the ray.\r\n\r\n    // Define the operation we will use (min or max)\r\n    #if vtkBlendMode == 1\r\n    #define OP max\r\n    #else\r\n    #define OP min\r\n    #endif\r\n\r\n    // If the clipping range is shorter than the sample distance\r\n    // we can skip the sampling loop along the ray.\r\n    if (raySteps <= 1.0)\r\n    {\r\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\r\n      return;\r\n    }\r\n\r\n    vec4 value = tValue;\r\n    posIS += (jitter*stepIS);\r\n\r\n    // Sample along the ray until MaximumSamplesValue,\r\n    // ending slightly inside the total distance\r\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\r\n    {\r\n      // If we have reached the last step, break\r\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\r\n\r\n      // compute the scalar\r\n      tValue = getTextureValue(posIS);\r\n\r\n      // Update the maximum value if necessary\r\n      value = OP(tValue, value);\r\n\r\n      // Otherwise, continue along the ray\r\n      stepsTraveled++;\r\n      posIS += stepIS;\r\n    }\r\n\r\n    // Perform the last step along the ray using the\r\n    // residual distance\r\n    posIS = endIS;\r\n    tValue = getTextureValue(posIS);\r\n    value = OP(tValue, value);\r\n\r\n    // Now map through opacity and color\r\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\r\n  #endif\r\n  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND\r\n    vec4 sum = vec4(0.);\r\n\r\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\r\n      sum += tValue;\r\n    }\r\n\r\n    if (raySteps <= 1.0) {\r\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\r\n      return;\r\n    }\r\n\r\n    posIS += (jitter*stepIS);\r\n\r\n    // Sample along the ray until MaximumSamplesValue,\r\n    // ending slightly inside the total distance\r\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\r\n    {\r\n      // If we have reached the last step, break\r\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\r\n\r\n      // compute the scalar\r\n      tValue = getTextureValue(posIS);\r\n\r\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\r\n      // Notes:\r\n      // - We are comparing all values in the texture to see if any of them\r\n      //   are outside of the scalar range. In the future we might want to allow\r\n      //   scalar ranges for each component.\r\n      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\r\n        // Sum the values across each step in the path\r\n        sum += tValue;\r\n      }\r\n      stepsTraveled++;\r\n      posIS += stepIS;\r\n    }\r\n\r\n    // Perform the last step along the ray using the\r\n    // residual distance\r\n    posIS = endIS;\r\n\r\n    // compute the scalar\r\n    tValue = getTextureValue(posIS);\r\n\r\n    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation\r\n    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {\r\n      sum += tValue;\r\n\r\n      stepsTraveled++;\r\n    }\r\n\r\n    #if vtkBlendMode == 3 // Average\r\n      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\r\n    #endif\r\n\r\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\r\n  #endif\r\n  #if vtkBlendMode == 5 // RADON\r\n    float normalizedRayIntensity = 1.0;\r\n\r\n    // handle very thin volumes\r\n    if (raySteps <= 1.0)\r\n    {\r\n      tValue = getTextureValue(posIS);\r\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\r\n      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));\r\n      return;\r\n    }\r\n\r\n    posIS += (jitter*stepIS);\r\n\r\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\r\n    {\r\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\r\n\r\n      // compute the scalar value\r\n      tValue = getTextureValue(posIS);\r\n\r\n      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity\r\n      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\r\n\r\n      posIS += stepIS;\r\n      stepsTraveled++;\r\n    }\r\n\r\n    // map normalizedRayIntensity to color\r\n    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));\r\n\r\n  #endif\r\n}\r\n\r\n//=======================================================================\r\n// Compute a new start and end point for a given ray based\r\n// on the provided bounded clipping plane (aka a rectangle)\r\nvoid getRayPointIntersectionBounds(\r\n  vec3 rayPos, vec3 rayDir,\r\n  vec3 planeDir, float planeDist,\r\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\r\n  float vSize1, float vSize2)\r\n{\r\n  float result = dot(rayDir, planeDir);\r\n  if (abs(result) < 1e-6)\r\n  {\r\n    return;\r\n  }\r\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\r\n  vec3 xposVC = rayPos + rayDir*result;\r\n  vec3 vxpos = xposVC - vOriginVC;\r\n  vec2 vpos = vec2(\r\n    dot(vxpos, vPlaneX),\r\n    dot(vxpos, vPlaneY));\r\n\r\n  // on some apple nvidia systems this does not work\r\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\r\n  //     vpos.y < 0.0 || vpos.y > vSize2)\r\n  // even just\r\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\r\n  // fails\r\n  // so instead we compute a value that represents in and out\r\n  //and then compute the return using this value\r\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\r\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\r\n\r\n  tbounds = mix(\r\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\r\n   tbounds, // out value\r\n   check);  // 0 in 1 out\r\n}\r\n\r\n//=======================================================================\r\n// given a\r\n// - ray direction (rayDir)\r\n// - starting point (vertexVCVSOutput)\r\n// - bounding planes of the volume\r\n// - optionally depth buffer values\r\n// - far clipping plane\r\n// compute the start/end distances of the ray we need to cast\r\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\r\n{\r\n  vec2 dists = vec2(100.0*camFar, -1.0);\r\n\r\n  vec3 vSize = vSpacing*tdims;\r\n\r\n  // all this is in View Coordinates\r\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\r\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\r\n    vSize.y, vSize.z);\r\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\r\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\r\n    vSize.y, vSize.z);\r\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\r\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\r\n    vSize.x, vSize.z);\r\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\r\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\r\n    vSize.x, vSize.z);\r\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\r\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\r\n    vSize.x, vSize.y);\r\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\r\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\r\n    vSize.x, vSize.y);\r\n\r\n  //VTK::ClipPlane::Impl\r\n\r\n  // do not go behind front clipping plane\r\n  dists.x = max(0.0,dists.x);\r\n\r\n  // do not go PAST far clipping plane\r\n  float farDist = -camThick/rayDir.z;\r\n  dists.y = min(farDist,dists.y);\r\n\r\n  // Do not go past the zbuffer value if set\r\n  // This is used for intermixing opaque geometry\r\n  //VTK::ZBuffer::Impl\r\n\r\n  return dists;\r\n}\r\n\r\n//=======================================================================\r\n// Compute the index space starting position (pos) and end\r\n// position\r\n//\r\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)\r\n{\r\n  // compute starting and ending values in volume space\r\n  pos = vertexVCVSOutput + dists.x*rayDir;\r\n  pos = pos - vOriginVC;\r\n  // convert to volume basis and origin\r\n  pos = vec3(\r\n    dot(pos, vPlaneNormal0),\r\n    dot(pos, vPlaneNormal2),\r\n    dot(pos, vPlaneNormal4));\r\n\r\n  endPos = vertexVCVSOutput + dists.y*rayDir;\r\n  endPos = endPos - vOriginVC;\r\n  endPos = vec3(\r\n    dot(endPos, vPlaneNormal0),\r\n    dot(endPos, vPlaneNormal2),\r\n    dot(endPos, vPlaneNormal4));\r\n\r\n  float delta = length(endPos - pos);\r\n\r\n  pos *= vVCToIJK;\r\n  endPos *= vVCToIJK;\r\n\r\n  float delta2 = length(endPos - pos);\r\n  sampleDistanceIS = sampleDistance*delta2/delta;\r\n  #ifdef VolumeShadowOn\r\n    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;\r\n  #endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\r\n  if (cameraParallel == 1)\r\n  {\r\n    // Camera is parallel, so the rayDir is just the direction of the camera.\r\n    rayDirVC = vec3(0.0, 0.0, -1.0);\r\n  } else {\r\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\r\n    rayDirVC = normalize(vertexVCVSOutput);\r\n  }\r\n\r\n  vec3 tdims = vec3(volumeDimensions);\r\n\r\n  // compute the start and end points for the ray\r\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\r\n\r\n  // do we need to composite? aka does the ray have any length\r\n  // If not, bail out early\r\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\r\n  {\r\n    discard;\r\n  }\r\n\r\n  // IS = Index Space\r\n  vec3 posIS;\r\n  vec3 endIS;\r\n  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);\r\n\r\n  // Perform the blending operation along the ray\r\n  applyBlend(posIS, endIS, tdims);\r\n}\r\n";

export { vtkVolumeFS as v };
